<ul>
<li><a href="#graphics">Graphics</a>
<ul>
<li><a href="#types">Types</a>
<ul>
<li><a href="#keyframe">Keyframe</a></li>
<li><a href="#keyframe-set">keyframe set</a></li>
<li><a href="#draw-function">draw function</a></li>
<li><a href="#sprite-state">sprite state</a></li>
</ul>
</li>
<li><a href="#interaces">Interaces</a>
<ul>
<li><a href="#isprite">ISprite</a></li>
</ul>
</li>
<li><a href="#easing-functions">Easing functions</a></li>
<li><a href="#classes">Classes</a>
<ul>
<li><a href="#vector-sprite">Vector Sprite</a>
<ul>
<li><a href="#constructor">constructor</a></li>
<li><a href="#public-variables">public variables</a></li>
<li><a href="#methods">methods</a></li>
<li><a href="#example-code">Example Code</a></li>
</ul>
</li>
<li><a href="#dynamic-vector-sprite">Dynamic Vector Sprite</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>Graphics</h1>
<pre><code class="language-ts">import { Graphics } from './Bunas';
</code></pre>
<p>This module provides method for rendering imagagry to the canvas during your game. This can include anything from genreating animated sprites from sprite sheets or vector descriptions, background images, tile sets or GUI features needed for your project, such as menus and heads-up displays.</p>
<h2>Types</h2>
<h3>Keyframe</h3>
<pre><code class="language-ts">type keyframe = number | number[] | number[][] | (number | string)[][];

let a : keyframe = 5,
    b : keyframe = [10, 20, 30, 25],
    c : keyframe = [[0, 10], [0.3, 30], [0.9, 20]],
    d : keyframe = [[0, 10], [0.3, 30, 'bounceIn'], [0.9, 20, 'bounceOut']]
</code></pre>
<p>A <em>keyframe</em> describes the values a property will take over the course of an animation.<br>
If a <em>number</em> is provided, the property will remain constant throughout the animation.<br>
If a <em>number[]</em> array is provided the values of the property will vary between each value in the array at equal intervals before looping back to the first value as the animation cycle repeats.<br>
If a you want to specific exact timings for your animation, instead of letting the time between each value be equal, you can provide a nested <em>number[][]</em> array where each inner array has two values, the first a number between 0 - 1 to indicate a point in the animation cycle and the second equal to the value of the property to be reached at that point.<br>
A third string value can be added to these array values to indicate the <em>easing function</em> used between that frame and the next.</p>
<h3>keyframe set</h3>
<pre><code class="language-ts">type keyframeSet = { [property: string] : keyframe }

let set : keyframeSet = {
    height : [0, 20, 50],
    width  : [[0.2, 20], [0.8, 30]]
}
</code></pre>
<p>A <em>keyframeSet</em> is an object where each parameter describes the <em>keyframe</em> to animate a particular property.
On each animation frame, each of these properties are mapped to the single values they would have on that particular frame before being sent to a <em>drawFunction</em>.</p>
<h3>draw function</h3>
<pre><code class="language-ts">type drawFunction = (frame: { [property: string] : number }, ctx: CanvasRenderingContext2D)=&gt;void
</code></pre>
<p>A <em>draw function</em> is a function which executes a series of canvas drawing calls; such as <em>ctx.fillRect()</em>, <em>ctx.lineTo(),</em> etc.; to draw a vector image.
The <em>frame</em> input is an object derived from a <em>keyframe set</em>. On each frame of animation, the values of each property in a <em>keyframe set</em> will be mapped to its current single value at that moment of time. This mapped keyframe set becomes the frame input to a <em>draw function</em>
The <em>ctx</em> input is simply the current canvas drawing context.</p>
<h3>sprite state</h3>
<pre><code class="language-ts">export type spriteState  = {
    duration   : number,
    elements   : { [element: string] : keyframeSet }
    fr?        : number,
    iteration? : number
    easeIn?    : string,
    easeOut?   : string,
    onEnd?     : ()=&gt;void
}
</code></pre>
<p>A sprite state is</p>
<h2>Interaces</h2>
<h3>ISprite</h3>
<pre><code class="language-ts">interface ISprite {
    duration : number;
    draw     : (x: number, y: number, ang: number, ctx: CanvasRenderingContext2D)=&gt;void;
    toggle   : (play: boolean, setFrame: number)=&gt;void;
    reverse  : ()=&gt;void;
    onEnd    : ()=&gt;void;
};
</code></pre>
<p>In the <em>Graphics</em> module, serveral classes are prvided from creating differnet kinds of sprites. Each of these classes will implement the ISprite interface ensuing that regardles of the method of cration, each sprite in a <em>Bunas</em> game can b handled with the same set of functions.</p>
<h2>Easing functions</h2>
<p>Many animation functions will accept a string input called <em>ease</em>. This input describes the effect to be used when transitioning from one value to another in an animation cycle.
The following easing function names are accepted in this module:</p>
<ul>
<li>linear</li>
<li>sine
<ul>
<li>sineIn</li>
<li>sineOut</li>
</ul>
</li>
<li>cubic
<ul>
<li>cubicIn</li>
<li>cubicOut</li>
</ul>
</li>
<li>quad
<ul>
<li>quadIn</li>
<li>quadOut</li>
</ul>
</li>
<li>quart
<ul>
<li>quartIn</li>
<li>quartOut</li>
</ul>
</li>
<li>quint</li>
<li>expo
<ul>
<li>expoIn</li>
<li>expoOut</li>
</ul>
</li>
<li>back
<ul>
<li>backIn</li>
<li>backOut</li>
</ul>
</li>
<li>bounce
<ul>
<li>bounceIn</li>
<li>bounceOut</li>
</ul>
</li>
<li>elastic
<ul>
<li>elasticIn</li>
<li>elasticOut</li>
</ul>
</li>
<li>circular
<ul>
<li>circular</li>
<li>In</li>
<li>circularOut</li>
</ul>
</li>
</ul>
<p>When none is provided, a <em>sine</em> easing will always be used by default.</p>
<h2>Classes</h2>
<h3>Vector Sprite</h3>
<p>A sprite created from a <em>draw function</em> containing a series of canvas drawing commands, and an optional <em>keyframe set</em> which describes the animation of parameters which can be used in the draw function.</p>
<h4>constructor</h4>
<pre><code class="language-ts">constructor(
    drawFunction :drawFunction,
    keyframeSet  :keyframeSet = null,
    duration     :number = 30
) 
</code></pre>
<p>The <em>keyframe set</em> is an object where each key-value pair is the name of a parameter and the values of that parameters that need to be interpolated during the animation cycle. It can take any of the following forms:</p>
<pre><code class="language-ts">keyframeSet = {
    //constant value for whole animation
    height : 20,

    //transition though values at equal intervals
    width : [10, 30, 50, 40],

    //specify fraction of animation for each value
    left  : [[0, 10], [0.4, 30], [0.8, 40]],
    
    //specify easing function between each frame (sine by default)
    top   : [[0, 10, 'bounce'], [0.5, 50, 'quad']] 
}
</code></pre>
<p>The draw function takes two inputs:</p>
<pre><code class="language-ts">function(frame: {[propertyName] : number}, ctx: Canvas2DRenderingContext) { }
</code></pre>
<p><em>frame</em> contains a list of property values for the current animation frame. The frame object will contain the same keys as the keyframeSet but with each value mapped to its value for the current animation frame.
<em>ctx</em> is simply the current canvas drawing context.</p>
<p>The sprite also takes a <em>duration</em> input, which is the number of game frames a single animation cycle of the sprite will last.</p>
<h4>public variables</h4>
<pre><code class="language-ts">drawFunction :drawFunction
keyFrameset  :keyframeSet,
duration     :number;
fr           :number
onEnd        :()=&gt;void
</code></pre>
<p><em>fr</em> is the current animation frame of the sprite. Since this is a vector sprite this can be any decimal number between 0 and 1 repersenting the fraction of the animation which has elasped so far.</p>
<p><em>onEnd</em> is a function which, if set, will be called at the end of every animation cycle of the sprite.</p>
<h4>methods</h4>
<pre><code class="language-ts">draw(x: number, y: number, ang: number, ctx: CanvasRenderingContext2D) =&gt; void
</code></pre>
<p>Draws the sprite in next frame of its animation.
<em>x</em>, <em>y</em> and <em>ang</em> are the position and rotation to draw the sprite on the canvas.</p>
<p><em>ctx</em> is the current game canvas context.</p>
<pre><code class="language-ts">toggle(play: boolean = null, setFrame?: number)=&gt; void
</code></pre>
<p>Pauses or resumes the animation of the sprite. When paused, each call to draw() will render the sprite but will not increment its animation frame.
If <em>play</em> is true, the animation will play; false, it will pause; unset it will change to the state is not currently in.
<em>setFrame</em> can be set to a value between 0 and 1 to set the animation frame of the sprite before pausing / resuming.</p>
<pre><code class="language-ts">reverse()=&gt; void
</code></pre>
<p>Reverses the direction of the play of the animation cycle.</p>
<h4>Example Code</h4>
<pre><code class="language-ts">//Static sprite
drawFunction = () =&gt; ctx.fillRect(0, 0, 200, 100);

//Sprite with simple keyframe animation
frame = {
    width : [200, 300],
    height: [100, 10, 60, 10]
};
drawFunction = (frame) =&gt; ctx.fillRect(0, 0, frame.width, frame.height);

//More complex keyframe sprite
frame = {
    width : [[0, 200, 'bounce'], [90, 300, 'backOut']],
    height: 50
};
drawFunction = (frame) =&gt; ctx.fillRect(0, 0, frame.width, frame.height);

//Init and call
let sprite = new Graphics.VectorSprite(drawFunction, frame, 30);
sprite.draw(100, 100, 0, ctx);
</code></pre>
<h3>Dynamic Vector Sprite</h3>
<p>This class allows you to define several elements which make up a sprite, differnet states the sprite can exist in an differnet animated actions the sprite can perform.
You can then trigger the sprite to change elements, states or perform actions with each animation eaing smoothly with the next.</p>
<pre><code class="language-ts">
</code></pre>
